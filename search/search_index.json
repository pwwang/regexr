{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"regexr Regular expressions for humans Instead of writing a regular expression to match an URL: # need to be compiled with re.X regex = r ''' ^(?P<protocol>http|https|ftp|mailto|file|data|irc):// (?P<domain>[A-Za-z0-9-]{0,63}(?:\\.[A-Za-z0-9-]{0,63})+) (?::(?P<port>\\d{1,4}))? (?P<path>/*(?:/*[A-Za-z0-9\\-._]+/*)*) (?:\\?(?P<query>.*?))? (?:\\#(?P<fragment>.*))?$ ''' You can write: regexr = Regexr ( START , ## match the protocol Or ( 'http' , 'https' , 'ftp' , 'mailto' , 'file' , 'data' , 'irc' , capture = \"protocol\" ), '://' , ## match the domain Capture ( Repeat ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , '-' ), m = 0 , n = 63 ), OneOrMore ( DOT , Repeat ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , '-' ), m = 0 , n = 63 )), name = \"domain\" , ), ## match the port Maybe ( ':' , Capture ( Repeat ( DIGIT , m = 1 , n = 4 ), name = \"port\" )), ## match the path Capture ( ZeroOrMore ( '/' ), ZeroOrMore ( ZeroOrMore ( '/' ), OneOrMore ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , r '\\-._' )), ZeroOrMore ( '/' ), ), name = \"path\" , ), ## match the query Maybe ( \"?\" , Capture ( Lazy ( MAYBE_ANYCHARS ), name = \"query\" )), ## and finally the fragment Maybe ( \"#\" , Capture ( MAYBE_ANYCHARS , name = \"fragment\" )), END , ) Inspired by rex for R and Regularity for Ruby. Why? We have re.X to compile a regular expression in verbose mode, but sometimes it is still difficult to read/write and error-prone. Easy to read/write regular expressions For example, []] might need a second to understand it. But we can write it as OneOfChars(\"]\") and it will be easier to read. Easy to write regular expressions with autocompletions from IDEs When we write raw regex, we can't get any hints from IDEs Non-capturing for groups whether possible For example, with Maybe(Maybe(\"a\", \"b)) we get (?:(?:ab)?)? Easy to avoid unintentional errors For example, sometimes it's difficult to debug with r\"(?P<a>>\\d+)\\D+\\a when we accidentally put one more > after the capturing name. Easy to avoid ambiguity For example, ? could be a quantifier meaning 0 or 1 match. It could also be a non-greedy (lazy) modifier for quantifiers. It's easy to be distinguished by Maybe(...) and Lazy(...) (or quantifiers with lazy=True ). Easily avoid unbalanced parentheses/brackets/braces Especially when we want to match them. For example, Capture(\"(\") instead of (\\() . Usage More examples Matching a phone number like XXX-XXX-XXXX or (XXX) XXX XXXX Regexr ( START , # match the first part Maybe ( Capture ( '(' , name = \"open_paren\" )), RepeatExact ( DIGIT , m = 3 ), Conditional ( \"open_paren\" , yes = \")\" ), Maybe ( OneOfChars ( '- ' )), # match the second part RepeatExact ( DIGIT , m = 3 ), Maybe ( OneOfChars ( '- ' )), # match the third part RepeatExact ( DIGIT , m = 4 ), END , ) # compiles to # ^(?P<open_paren>\\()?\\d{3}(?(open_paren)\\))[- ]?\\d{3}[- ]?\\d{4}$ Matching an IP address # Define the pattern for one part of xxx.xxx.xxx.xxx ip_part = Or ( # Use Concat instead of NonCapture to avoid brackets # 250-255 Concat ( \"25\" , OneOfChars ( '0-5' )), # 200-249 Concat ( \"2\" , OneOfChars ( '0-4' ), DIGIT ), # 000-199 Concat ( Or ( \"0\" , \"1\" ), RepeatExact ( DIGIT , m = 2 )), # 00-99 Repeat ( DIGIT , m = 1 , n = 2 ), ) Regexr ( START , ip_part , RepeatExact ( DOT , ip_part , m = 3 ), END , ) # compiles to # ^(?:25[0-5]|2[0-4]\\d|(?:0|1)\\d{2}|\\d{1,2})(?:\\.(?:25[0-5]|2[0-4]\\d|(?:0|1)\\d{2}|\\d{1,2})){3}$ Matching an HTML tag roughly (without attributes) Regexr ( START , \"<\" , Capture ( WORDS , name = \"tag\" ), \">\" , Lazy ( ANYCHARS ), \"</\" , Captured ( \"tag\" ), \">\" , END , ) # compiles to # ^<(?P<tag>\\w+)>.+?</(?P=tag)>$ Pretty print a Regexr object With the example at the very beginning (matching an URL), we can pretty print it: # print(regexr.pretty()) # prints: ^ (?P<protocol>http|https|ftp|mailto|file|data|irc) :// (?P<domain> [A-Za-z0-9-]{0,63} (?:\\.[A-Za-z0-9-]{0,63})+ ) (?::(?P<port>\\d{1,4}))? (?P<path> /* (?:/*[A-Za-z0-9\\-._]+/*)* ) (?:\\?(?P<query>.*?))? (?:\\#(?P<fragment>.*))? $ Compile a Regexr directly Regexr ( \"a\" ) . compile ( re . I ) . match ( \"A\" ) # <re.Match object; span=(0, 1), match='A'> API documentation https://pwwang.github.io/regexr/ TODO Support bytes","title":"Home"},{"location":"#regexr","text":"Regular expressions for humans Instead of writing a regular expression to match an URL: # need to be compiled with re.X regex = r ''' ^(?P<protocol>http|https|ftp|mailto|file|data|irc):// (?P<domain>[A-Za-z0-9-]{0,63}(?:\\.[A-Za-z0-9-]{0,63})+) (?::(?P<port>\\d{1,4}))? (?P<path>/*(?:/*[A-Za-z0-9\\-._]+/*)*) (?:\\?(?P<query>.*?))? (?:\\#(?P<fragment>.*))?$ ''' You can write: regexr = Regexr ( START , ## match the protocol Or ( 'http' , 'https' , 'ftp' , 'mailto' , 'file' , 'data' , 'irc' , capture = \"protocol\" ), '://' , ## match the domain Capture ( Repeat ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , '-' ), m = 0 , n = 63 ), OneOrMore ( DOT , Repeat ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , '-' ), m = 0 , n = 63 )), name = \"domain\" , ), ## match the port Maybe ( ':' , Capture ( Repeat ( DIGIT , m = 1 , n = 4 ), name = \"port\" )), ## match the path Capture ( ZeroOrMore ( '/' ), ZeroOrMore ( ZeroOrMore ( '/' ), OneOrMore ( OneOfChars ( 'A-Z' , 'a-z' , '0-9' , r '\\-._' )), ZeroOrMore ( '/' ), ), name = \"path\" , ), ## match the query Maybe ( \"?\" , Capture ( Lazy ( MAYBE_ANYCHARS ), name = \"query\" )), ## and finally the fragment Maybe ( \"#\" , Capture ( MAYBE_ANYCHARS , name = \"fragment\" )), END , ) Inspired by rex for R and Regularity for Ruby.","title":"regexr"},{"location":"#why","text":"We have re.X to compile a regular expression in verbose mode, but sometimes it is still difficult to read/write and error-prone. Easy to read/write regular expressions For example, []] might need a second to understand it. But we can write it as OneOfChars(\"]\") and it will be easier to read. Easy to write regular expressions with autocompletions from IDEs When we write raw regex, we can't get any hints from IDEs Non-capturing for groups whether possible For example, with Maybe(Maybe(\"a\", \"b)) we get (?:(?:ab)?)? Easy to avoid unintentional errors For example, sometimes it's difficult to debug with r\"(?P<a>>\\d+)\\D+\\a when we accidentally put one more > after the capturing name. Easy to avoid ambiguity For example, ? could be a quantifier meaning 0 or 1 match. It could also be a non-greedy (lazy) modifier for quantifiers. It's easy to be distinguished by Maybe(...) and Lazy(...) (or quantifiers with lazy=True ). Easily avoid unbalanced parentheses/brackets/braces Especially when we want to match them. For example, Capture(\"(\") instead of (\\() .","title":"Why?"},{"location":"#usage","text":"","title":"Usage"},{"location":"#more-examples","text":"Matching a phone number like XXX-XXX-XXXX or (XXX) XXX XXXX Regexr ( START , # match the first part Maybe ( Capture ( '(' , name = \"open_paren\" )), RepeatExact ( DIGIT , m = 3 ), Conditional ( \"open_paren\" , yes = \")\" ), Maybe ( OneOfChars ( '- ' )), # match the second part RepeatExact ( DIGIT , m = 3 ), Maybe ( OneOfChars ( '- ' )), # match the third part RepeatExact ( DIGIT , m = 4 ), END , ) # compiles to # ^(?P<open_paren>\\()?\\d{3}(?(open_paren)\\))[- ]?\\d{3}[- ]?\\d{4}$ Matching an IP address # Define the pattern for one part of xxx.xxx.xxx.xxx ip_part = Or ( # Use Concat instead of NonCapture to avoid brackets # 250-255 Concat ( \"25\" , OneOfChars ( '0-5' )), # 200-249 Concat ( \"2\" , OneOfChars ( '0-4' ), DIGIT ), # 000-199 Concat ( Or ( \"0\" , \"1\" ), RepeatExact ( DIGIT , m = 2 )), # 00-99 Repeat ( DIGIT , m = 1 , n = 2 ), ) Regexr ( START , ip_part , RepeatExact ( DOT , ip_part , m = 3 ), END , ) # compiles to # ^(?:25[0-5]|2[0-4]\\d|(?:0|1)\\d{2}|\\d{1,2})(?:\\.(?:25[0-5]|2[0-4]\\d|(?:0|1)\\d{2}|\\d{1,2})){3}$ Matching an HTML tag roughly (without attributes) Regexr ( START , \"<\" , Capture ( WORDS , name = \"tag\" ), \">\" , Lazy ( ANYCHARS ), \"</\" , Captured ( \"tag\" ), \">\" , END , ) # compiles to # ^<(?P<tag>\\w+)>.+?</(?P=tag)>$","title":"More examples"},{"location":"#pretty-print-a-regexr-object","text":"With the example at the very beginning (matching an URL), we can pretty print it: # print(regexr.pretty()) # prints: ^ (?P<protocol>http|https|ftp|mailto|file|data|irc) :// (?P<domain> [A-Za-z0-9-]{0,63} (?:\\.[A-Za-z0-9-]{0,63})+ ) (?::(?P<port>\\d{1,4}))? (?P<path> /* (?:/*[A-Za-z0-9\\-._]+/*)* ) (?:\\?(?P<query>.*?))? (?:\\#(?P<fragment>.*))? $","title":"Pretty print a Regexr object"},{"location":"#compile-a-regexr-directly","text":"Regexr ( \"a\" ) . compile ( re . I ) . match ( \"A\" ) # <re.Match object; span=(0, 1), match='A'>","title":"Compile a Regexr directly"},{"location":"#api-documentation","text":"https://pwwang.github.io/regexr/","title":"API documentation"},{"location":"#todo","text":"Support bytes","title":"TODO"},{"location":"CHANGELOG/","text":"0.0.2 \ud83e\ude79 Escape yes and no for Conditional by default \u2728 Support Flag (?aiLmsux) \u2728 Support inline flags (?aiLmsux-imsx:...) \u2728 Allow argument alias name of capture for Capture() 0.0.1 \ud83c\udf89 Init","title":"Change log"},{"location":"CHANGELOG/#002","text":"\ud83e\ude79 Escape yes and no for Conditional by default \u2728 Support Flag (?aiLmsux) \u2728 Support inline flags (?aiLmsux-imsx:...) \u2728 Allow argument alias name of capture for Capture()","title":"0.0.2"},{"location":"CHANGELOG/#001","text":"\ud83c\udf89 Init","title":"0.0.1"},{"location":"api/regexr/","text":"package regexr </> module regexr . string </> Regular expressions for humans Predefined patterns: START = Raw(\"^\", entire=True) START_OF_STRING = Raw(r\"\\A\", entire=True) END = Raw(\"$\", entire=True) END_OF_STRING = Raw(r\"\\Z\", entire=True) NUMBER = DIGIT = Raw(r\"\\d\", entire=True) NUMBERS = DIGITS = Raw(r\"\\d+\", entire=True) MAYBE_NUMBERS = MAYBE_DIGITS = Raw(r\"\\d*\", entire=True) NON_NUMBER = NON_DIGIT = Raw(r\"\\D\", entire=True) WORD = Raw(r\"\\w\", entire=True) WORDS = Raw(r\"\\w+\", entire=True) MAYBE_WORDS = Raw(r\"\\w*\", entire=True) NON_WORD = Raw(r\"\\W\", entire=True) WORD_BOUNDARY = Raw(r\"\\b\", entire=True) NON_WORD_BOUNDARY = Raw(r\"\\B\", entire=True) WHITESPACE = Raw(r\"\\s\", entire=True) WHITESPACES = Raw(r\"\\s+\", entire=True) MAYBE_WHITESPACES = Raw(r\"\\s*\", entire=True) NON_WHITESPACE = Raw(r\"\\S\", entire=True) SPACE = Raw(\" \", entire=True) SPACES = Raw(\" +\", entire=True) MAYBE_SPACES = Raw(\" *\", entire=True) TAB = Raw(r\"\\t\", entire=True) DOT = Raw(r\"\\.\", entire=True) ANYCHAR = Raw(\".\", entire=True) ANYCHARS = Raw(\".+\", entire=True) MAYBE_ANYCHARS = Raw(\".*\", entire=True) LETTER = Raw(\"[a-zA-Z]\", entire=True) LETTERS = Raw(\"[a-zA-Z]+\", entire=True) MAYBE_LETTERS = Raw(\"[a-zA-Z]*\", entire=True) LOWERCASE = Raw(\"[a-z]\", entire=True) LOWERCASES = Raw(\"[a-z]+\", entire=True) MAYBE_LOWERCASES = Raw(\"[a-z]*\", entire=True) UPPERCASE = Raw(\"[A-Z]\", entire=True) UPPERCASES = Raw(\"[A-Z]+\", entire=True) MAYBE_UPPERCASES = Raw(\"[A-Z]*\", entire=True) ALNUM = Raw(\"[a-zA-Z0-9]\", entire=True) ALNUMS = Raw(\"[a-zA-Z0-9]+\", entire=True) MAYBE_ALNUMS = Raw(\"[a-zA-Z0-9]*\", entire=True) Classes Segment \u2014 Segments of a regular expression </> CharClass \u2014 Used to indicat a set of characters wrapped by [] </> OneOfChars \u2014 Positive character set [...] </> NoneOfChars \u2014 Negative character set [^...] </> Look \u2014 Look ahead or behind </> LookAhead \u2014 Look ahead (?=...) </> LookBehind \u2014 Look behind (?<=...) </> LookAheadNot \u2014 Look ahead not (?!...) </> LookBehindNot \u2014 Look behind not (?<!...) </> Quantifier ( *args , lazy , capture , flags , deflags ) \u2014 Quantifier + , * , ? , {m} or {m,n} </> ZeroOrMore \u2014 * zero or more times </> OneOrMore \u2014 + one or more times </> Maybe \u2014 ? zero or one times </> Repeat \u2014 Match from m to n repetitions {m,n} or {m,} </> RepeatExact \u2014 Match exact m repetitions {m} </> Lazy \u2014 Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? </> Flag \u2014 Flag (?aiLmsux) </> InlineFlag \u2014 Inline flag (?aiLmsux-imsx:...) </> Raw \u2014 Raw strings without escaping </> Or \u2014 | connected segments </> Capture \u2014 Capture a match (...) </> NonCapture \u2014 Non-capturing grouping (?:...) </> Concat \u2014 Concatenate segments </> Conditional \u2014 (?(...)yes|no) conditional pattern </> Captured \u2014 (?P=name) captured group or \\1, \\2, ... </> Regexr ( Regexr ) \u2014 The entrance of the package to compose a regular expression </>","title":"regexr"},{"location":"api/regexr/#regexr","text":"</> module","title":"regexr"},{"location":"api/regexr/#regexrstring","text":"</> Regular expressions for humans Predefined patterns: START = Raw(\"^\", entire=True) START_OF_STRING = Raw(r\"\\A\", entire=True) END = Raw(\"$\", entire=True) END_OF_STRING = Raw(r\"\\Z\", entire=True) NUMBER = DIGIT = Raw(r\"\\d\", entire=True) NUMBERS = DIGITS = Raw(r\"\\d+\", entire=True) MAYBE_NUMBERS = MAYBE_DIGITS = Raw(r\"\\d*\", entire=True) NON_NUMBER = NON_DIGIT = Raw(r\"\\D\", entire=True) WORD = Raw(r\"\\w\", entire=True) WORDS = Raw(r\"\\w+\", entire=True) MAYBE_WORDS = Raw(r\"\\w*\", entire=True) NON_WORD = Raw(r\"\\W\", entire=True) WORD_BOUNDARY = Raw(r\"\\b\", entire=True) NON_WORD_BOUNDARY = Raw(r\"\\B\", entire=True) WHITESPACE = Raw(r\"\\s\", entire=True) WHITESPACES = Raw(r\"\\s+\", entire=True) MAYBE_WHITESPACES = Raw(r\"\\s*\", entire=True) NON_WHITESPACE = Raw(r\"\\S\", entire=True) SPACE = Raw(\" \", entire=True) SPACES = Raw(\" +\", entire=True) MAYBE_SPACES = Raw(\" *\", entire=True) TAB = Raw(r\"\\t\", entire=True) DOT = Raw(r\"\\.\", entire=True) ANYCHAR = Raw(\".\", entire=True) ANYCHARS = Raw(\".+\", entire=True) MAYBE_ANYCHARS = Raw(\".*\", entire=True) LETTER = Raw(\"[a-zA-Z]\", entire=True) LETTERS = Raw(\"[a-zA-Z]+\", entire=True) MAYBE_LETTERS = Raw(\"[a-zA-Z]*\", entire=True) LOWERCASE = Raw(\"[a-z]\", entire=True) LOWERCASES = Raw(\"[a-z]+\", entire=True) MAYBE_LOWERCASES = Raw(\"[a-z]*\", entire=True) UPPERCASE = Raw(\"[A-Z]\", entire=True) UPPERCASES = Raw(\"[A-Z]+\", entire=True) MAYBE_UPPERCASES = Raw(\"[A-Z]*\", entire=True) ALNUM = Raw(\"[a-zA-Z0-9]\", entire=True) ALNUMS = Raw(\"[a-zA-Z0-9]+\", entire=True) MAYBE_ALNUMS = Raw(\"[a-zA-Z0-9]*\", entire=True) Classes Segment \u2014 Segments of a regular expression </> CharClass \u2014 Used to indicat a set of characters wrapped by [] </> OneOfChars \u2014 Positive character set [...] </> NoneOfChars \u2014 Negative character set [^...] </> Look \u2014 Look ahead or behind </> LookAhead \u2014 Look ahead (?=...) </> LookBehind \u2014 Look behind (?<=...) </> LookAheadNot \u2014 Look ahead not (?!...) </> LookBehindNot \u2014 Look behind not (?<!...) </> Quantifier ( *args , lazy , capture , flags , deflags ) \u2014 Quantifier + , * , ? , {m} or {m,n} </> ZeroOrMore \u2014 * zero or more times </> OneOrMore \u2014 + one or more times </> Maybe \u2014 ? zero or one times </> Repeat \u2014 Match from m to n repetitions {m,n} or {m,} </> RepeatExact \u2014 Match exact m repetitions {m} </> Lazy \u2014 Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? </> Flag \u2014 Flag (?aiLmsux) </> InlineFlag \u2014 Inline flag (?aiLmsux-imsx:...) </> Raw \u2014 Raw strings without escaping </> Or \u2014 | connected segments </> Capture \u2014 Capture a match (...) </> NonCapture \u2014 Non-capturing grouping (?:...) </> Concat \u2014 Concatenate segments </> Conditional \u2014 (?(...)yes|no) conditional pattern </> Captured \u2014 (?P=name) captured group or \\1, \\2, ... </> Regexr ( Regexr ) \u2014 The entrance of the package to compose a regular expression </>","title":"regexr.string"},{"location":"api/regexr.string/","text":"module regexr . string </> Regular expressions for humans Predefined patterns: START = Raw(\"^\", entire=True) START_OF_STRING = Raw(r\"\\A\", entire=True) END = Raw(\"$\", entire=True) END_OF_STRING = Raw(r\"\\Z\", entire=True) NUMBER = DIGIT = Raw(r\"\\d\", entire=True) NUMBERS = DIGITS = Raw(r\"\\d+\", entire=True) MAYBE_NUMBERS = MAYBE_DIGITS = Raw(r\"\\d*\", entire=True) NON_NUMBER = NON_DIGIT = Raw(r\"\\D\", entire=True) WORD = Raw(r\"\\w\", entire=True) WORDS = Raw(r\"\\w+\", entire=True) MAYBE_WORDS = Raw(r\"\\w*\", entire=True) NON_WORD = Raw(r\"\\W\", entire=True) WORD_BOUNDARY = Raw(r\"\\b\", entire=True) NON_WORD_BOUNDARY = Raw(r\"\\B\", entire=True) WHITESPACE = Raw(r\"\\s\", entire=True) WHITESPACES = Raw(r\"\\s+\", entire=True) MAYBE_WHITESPACES = Raw(r\"\\s*\", entire=True) NON_WHITESPACE = Raw(r\"\\S\", entire=True) SPACE = Raw(\" \", entire=True) SPACES = Raw(\" +\", entire=True) MAYBE_SPACES = Raw(\" *\", entire=True) TAB = Raw(r\"\\t\", entire=True) DOT = Raw(r\"\\.\", entire=True) ANYCHAR = Raw(\".\", entire=True) ANYCHARS = Raw(\".+\", entire=True) MAYBE_ANYCHARS = Raw(\".*\", entire=True) LETTER = Raw(\"[a-zA-Z]\", entire=True) LETTERS = Raw(\"[a-zA-Z]+\", entire=True) MAYBE_LETTERS = Raw(\"[a-zA-Z]*\", entire=True) LOWERCASE = Raw(\"[a-z]\", entire=True) LOWERCASES = Raw(\"[a-z]+\", entire=True) MAYBE_LOWERCASES = Raw(\"[a-z]*\", entire=True) UPPERCASE = Raw(\"[A-Z]\", entire=True) UPPERCASES = Raw(\"[A-Z]+\", entire=True) MAYBE_UPPERCASES = Raw(\"[A-Z]*\", entire=True) ALNUM = Raw(\"[a-zA-Z0-9]\", entire=True) ALNUMS = Raw(\"[a-zA-Z0-9]+\", entire=True) MAYBE_ALNUMS = Raw(\"[a-zA-Z0-9]*\", entire=True) Classes Segment \u2014 Segments of a regular expression </> CharClass \u2014 Used to indicat a set of characters wrapped by [] </> OneOfChars \u2014 Positive character set [...] </> NoneOfChars \u2014 Negative character set [^...] </> Look \u2014 Look ahead or behind </> LookAhead \u2014 Look ahead (?=...) </> LookBehind \u2014 Look behind (?<=...) </> LookAheadNot \u2014 Look ahead not (?!...) </> LookBehindNot \u2014 Look behind not (?<!...) </> Quantifier ( *args , lazy , capture , flags , deflags ) \u2014 Quantifier + , * , ? , {m} or {m,n} </> ZeroOrMore \u2014 * zero or more times </> OneOrMore \u2014 + one or more times </> Maybe \u2014 ? zero or one times </> Repeat \u2014 Match from m to n repetitions {m,n} or {m,} </> RepeatExact \u2014 Match exact m repetitions {m} </> Lazy \u2014 Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? </> Flag \u2014 Flag (?aiLmsux) </> InlineFlag \u2014 Inline flag (?aiLmsux-imsx:...) </> Raw \u2014 Raw strings without escaping </> Or \u2014 | connected segments </> Capture \u2014 Capture a match (...) </> NonCapture \u2014 Non-capturing grouping (?:...) </> Concat \u2014 Concatenate segments </> Conditional \u2014 (?(...)yes|no) conditional pattern </> Captured \u2014 (?P=name) captured group or \\1, \\2, ... </> Regexr ( Regexr ) \u2014 The entrance of the package to compose a regular expression </> class regexr.string . Segment ( *args , capture=False , flags=None , deflags=None ) </> Segments of a regular expression ClassVars: NONCAPTURING_WRAPPING: Whether we should wrap the segment with brackets when capture is False . In some cases, for example, (abc)+ is already an entire group, it won't confuse the parser when it comes with other segments, such as (abc)+d . We don't need an extra brackets to separate it from other segments. However, we need brackets for other segments, such as a|b|c , because a|b|cd will confuse the parser. In such a case, we need (?:a|b|c)d if we don't need to capture the segment. Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. args \u2014 Another segments to be wrapped by this one. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . CharClass ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Used to indicat a set of characters wrapped by [] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . OneOfChars ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.CharClass regexr.string.Segment Positive character set [...] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . NoneOfChars ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.CharClass regexr.string.Segment Negative character set [^...] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Look ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Look ahead or behind Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . LookAhead ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Look regexr.string.Segment Look ahead (?=...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . LookBehind ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Look regexr.string.Segment Look behind (?<=...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . LookAheadNot ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Look regexr.string.Segment Look ahead not (?!...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . LookBehindNot ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Look regexr.string.Segment Look behind not (?<!...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. abstract class regexr.string . Quantifier ( *args , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Quantifier + , * , ? , {m} or {m,n} Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . ZeroOrMore ( *args , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Quantifier regexr.string.Segment * zero or more times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . OneOrMore ( *args , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Quantifier regexr.string.Segment + one or more times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Maybe ( *args , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Quantifier regexr.string.Segment ? zero or one times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Repeat ( *args , m , n=None , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Quantifier regexr.string.Segment Match from m to n repetitions {m,n} or {m,} Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . RepeatExact ( *args , m , lazy=False , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Quantifier regexr.string.Segment Match exact m repetitions {m} Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Lazy ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Flag ( *args ) </> Bases regexr.string.Segment Flag (?aiLmsux) Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . InlineFlag ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Inline flag (?aiLmsux-imsx:...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Raw ( *args , capture=False , entire=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Raw strings without escaping Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Or ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment | connected segments Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Capture ( *args , name=None , capture=None , flags=None , deflags=None ) </> Bases regexr.string.Segment Capture a match (...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . NonCapture ( *args , flags=None , deflags=None ) </> Bases regexr.string.Segment Non-capturing grouping (?:...) Parameters flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Concat ( *args , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment Concatenate segments Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Conditional ( id_or_name , yes , no=None , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment (?(...)yes|no) conditional pattern Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Captured ( id_or_name , capture=False , flags=None , deflags=None ) </> Bases regexr.string.Segment (?P=name) captured group or \\1, \\2, ... Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method pretty ( indent , level ) \u2192 str </> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method __str__ ( ) </> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class regexr.string . Regexr ( *segments ) \u2192 Regexr </> Bases str The entrance of the package to compose a regular expression It is actually a subclass of str , but with an extra method compile , which compiles the regular expression and returns a re.Pattern object. Parameters *segments (Segment or str) \u2014 The segments of the regular expression.When composing the regular expression, the segments are concatenated Methods __repr__ ( ) (str) \u2014 String representation of this regular expression </> compile ( flags ) (Pattern) \u2014 Compile the regular expression and return a re.Pattern object </> pretty ( indent ) (str) \u2014 Pretty print the regular expression </> method compile ( flags=0 ) \u2192 Pattern </> Compile the regular expression and return a re.Pattern object See also re.compile() Parameters flags (int, optional) \u2014 The flags to be used when compiling the regular expression. method pretty ( indent=' ' ) \u2192 str </> Pretty print the regular expression method __repr__ ( ) \u2192 str </> String representation of this regular expression","title":"regexr.string"},{"location":"api/regexr.string/#regexrstring","text":"</> Regular expressions for humans Predefined patterns: START = Raw(\"^\", entire=True) START_OF_STRING = Raw(r\"\\A\", entire=True) END = Raw(\"$\", entire=True) END_OF_STRING = Raw(r\"\\Z\", entire=True) NUMBER = DIGIT = Raw(r\"\\d\", entire=True) NUMBERS = DIGITS = Raw(r\"\\d+\", entire=True) MAYBE_NUMBERS = MAYBE_DIGITS = Raw(r\"\\d*\", entire=True) NON_NUMBER = NON_DIGIT = Raw(r\"\\D\", entire=True) WORD = Raw(r\"\\w\", entire=True) WORDS = Raw(r\"\\w+\", entire=True) MAYBE_WORDS = Raw(r\"\\w*\", entire=True) NON_WORD = Raw(r\"\\W\", entire=True) WORD_BOUNDARY = Raw(r\"\\b\", entire=True) NON_WORD_BOUNDARY = Raw(r\"\\B\", entire=True) WHITESPACE = Raw(r\"\\s\", entire=True) WHITESPACES = Raw(r\"\\s+\", entire=True) MAYBE_WHITESPACES = Raw(r\"\\s*\", entire=True) NON_WHITESPACE = Raw(r\"\\S\", entire=True) SPACE = Raw(\" \", entire=True) SPACES = Raw(\" +\", entire=True) MAYBE_SPACES = Raw(\" *\", entire=True) TAB = Raw(r\"\\t\", entire=True) DOT = Raw(r\"\\.\", entire=True) ANYCHAR = Raw(\".\", entire=True) ANYCHARS = Raw(\".+\", entire=True) MAYBE_ANYCHARS = Raw(\".*\", entire=True) LETTER = Raw(\"[a-zA-Z]\", entire=True) LETTERS = Raw(\"[a-zA-Z]+\", entire=True) MAYBE_LETTERS = Raw(\"[a-zA-Z]*\", entire=True) LOWERCASE = Raw(\"[a-z]\", entire=True) LOWERCASES = Raw(\"[a-z]+\", entire=True) MAYBE_LOWERCASES = Raw(\"[a-z]*\", entire=True) UPPERCASE = Raw(\"[A-Z]\", entire=True) UPPERCASES = Raw(\"[A-Z]+\", entire=True) MAYBE_UPPERCASES = Raw(\"[A-Z]*\", entire=True) ALNUM = Raw(\"[a-zA-Z0-9]\", entire=True) ALNUMS = Raw(\"[a-zA-Z0-9]+\", entire=True) MAYBE_ALNUMS = Raw(\"[a-zA-Z0-9]*\", entire=True) Classes Segment \u2014 Segments of a regular expression </> CharClass \u2014 Used to indicat a set of characters wrapped by [] </> OneOfChars \u2014 Positive character set [...] </> NoneOfChars \u2014 Negative character set [^...] </> Look \u2014 Look ahead or behind </> LookAhead \u2014 Look ahead (?=...) </> LookBehind \u2014 Look behind (?<=...) </> LookAheadNot \u2014 Look ahead not (?!...) </> LookBehindNot \u2014 Look behind not (?<!...) </> Quantifier ( *args , lazy , capture , flags , deflags ) \u2014 Quantifier + , * , ? , {m} or {m,n} </> ZeroOrMore \u2014 * zero or more times </> OneOrMore \u2014 + one or more times </> Maybe \u2014 ? zero or one times </> Repeat \u2014 Match from m to n repetitions {m,n} or {m,} </> RepeatExact \u2014 Match exact m repetitions {m} </> Lazy \u2014 Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? </> Flag \u2014 Flag (?aiLmsux) </> InlineFlag \u2014 Inline flag (?aiLmsux-imsx:...) </> Raw \u2014 Raw strings without escaping </> Or \u2014 | connected segments </> Capture \u2014 Capture a match (...) </> NonCapture \u2014 Non-capturing grouping (?:...) </> Concat \u2014 Concatenate segments </> Conditional \u2014 (?(...)yes|no) conditional pattern </> Captured \u2014 (?P=name) captured group or \\1, \\2, ... </> Regexr ( Regexr ) \u2014 The entrance of the package to compose a regular expression </> class","title":"regexr.string"},{"location":"api/regexr.string/#regexrstringsegment","text":"</> Segments of a regular expression ClassVars: NONCAPTURING_WRAPPING: Whether we should wrap the segment with brackets when capture is False . In some cases, for example, (abc)+ is already an entire group, it won't confuse the parser when it comes with other segments, such as (abc)+d . We don't need an extra brackets to separate it from other segments. However, we need brackets for other segments, such as a|b|c , because a|b|cd will confuse the parser. In such a case, we need (?:a|b|c)d if we don't need to capture the segment. Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. args \u2014 Another segments to be wrapped by this one. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Segment"},{"location":"api/regexr.string/#regexrstringsegmentpretty","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringcharclass","text":"</> Bases regexr.string.Segment Used to indicat a set of characters wrapped by [] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.CharClass"},{"location":"api/regexr.string/#regexrstringsegmentpretty_1","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_1","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringoneofchars","text":"</> Bases regexr.string.CharClass regexr.string.Segment Positive character set [...] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.OneOfChars"},{"location":"api/regexr.string/#regexrstringsegmentpretty_2","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_2","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringnoneofchars","text":"</> Bases regexr.string.CharClass regexr.string.Segment Negative character set [^...] Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.NoneOfChars"},{"location":"api/regexr.string/#regexrstringsegmentpretty_3","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_3","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlook","text":"</> Bases regexr.string.Segment Look ahead or behind Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Look"},{"location":"api/regexr.string/#regexrstringsegmentpretty_4","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_4","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlookahead","text":"</> Bases regexr.string.Look regexr.string.Segment Look ahead (?=...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.LookAhead"},{"location":"api/regexr.string/#regexrstringsegmentpretty_5","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_5","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlookbehind","text":"</> Bases regexr.string.Look regexr.string.Segment Look behind (?<=...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.LookBehind"},{"location":"api/regexr.string/#regexrstringsegmentpretty_6","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_6","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlookaheadnot","text":"</> Bases regexr.string.Look regexr.string.Segment Look ahead not (?!...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.LookAheadNot"},{"location":"api/regexr.string/#regexrstringsegmentpretty_7","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_7","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlookbehindnot","text":"</> Bases regexr.string.Look regexr.string.Segment Look behind not (?<!...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.LookBehindNot"},{"location":"api/regexr.string/#regexrstringsegmentpretty_8","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_8","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. abstract class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringquantifier","text":"</> Bases regexr.string.Segment Quantifier + , * , ? , {m} or {m,n} Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Quantifier"},{"location":"api/regexr.string/#regexrstringsegmentpretty_9","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_9","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringzeroormore","text":"</> Bases regexr.string.Quantifier regexr.string.Segment * zero or more times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.ZeroOrMore"},{"location":"api/regexr.string/#regexrstringsegmentpretty_10","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_10","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringoneormore","text":"</> Bases regexr.string.Quantifier regexr.string.Segment + one or more times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.OneOrMore"},{"location":"api/regexr.string/#regexrstringsegmentpretty_11","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_11","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringmaybe","text":"</> Bases regexr.string.Quantifier regexr.string.Segment ? zero or one times Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Maybe"},{"location":"api/regexr.string/#regexrstringsegmentpretty_12","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_12","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringrepeat","text":"</> Bases regexr.string.Quantifier regexr.string.Segment Match from m to n repetitions {m,n} or {m,} Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Repeat"},{"location":"api/regexr.string/#regexrstringsegmentpretty_13","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_13","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringrepeatexact","text":"</> Bases regexr.string.Quantifier regexr.string.Segment Match exact m repetitions {m} Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.RepeatExact"},{"location":"api/regexr.string/#regexrstringsegmentpretty_14","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_14","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringlazy","text":"</> Bases regexr.string.Segment Non-greedy modifier +? , *? , ?? , {m,}? or {m,n}? Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Lazy"},{"location":"api/regexr.string/#regexrstringsegmentpretty_15","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_15","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringflag","text":"</> Bases regexr.string.Segment Flag (?aiLmsux) Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Flag"},{"location":"api/regexr.string/#regexrstringsegmentpretty_16","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_16","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringinlineflag","text":"</> Bases regexr.string.Segment Inline flag (?aiLmsux-imsx:...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.InlineFlag"},{"location":"api/regexr.string/#regexrstringsegmentpretty_17","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_17","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringraw","text":"</> Bases regexr.string.Segment Raw strings without escaping Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Raw"},{"location":"api/regexr.string/#regexrstringsegmentpretty_18","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_18","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringor","text":"</> Bases regexr.string.Segment | connected segments Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Or"},{"location":"api/regexr.string/#regexrstringsegmentpretty_19","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_19","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringcapture","text":"</> Bases regexr.string.Segment Capture a match (...) Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Capture"},{"location":"api/regexr.string/#regexrstringsegmentpretty_20","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_20","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringnoncapture","text":"</> Bases regexr.string.Segment Non-capturing grouping (?:...) Parameters flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.NonCapture"},{"location":"api/regexr.string/#regexrstringsegmentpretty_21","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_21","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringconcat","text":"</> Bases regexr.string.Segment Concatenate segments Parameters capture (bool | str, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Concat"},{"location":"api/regexr.string/#regexrstringsegmentpretty_22","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_22","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringconditional","text":"</> Bases regexr.string.Segment (?(...)yes|no) conditional pattern Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Conditional"},{"location":"api/regexr.string/#regexrstringsegmentpretty_23","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_23","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringcaptured","text":"</> Bases regexr.string.Segment (?P=name) captured group or \\1, \\2, ... Parameters capture (bool, optional) \u2014 The name of the capture, False to disable capturing andTrue to capture without name. flags (int | str | Sequence[int | str], optional) \u2014 The flags to be used when compiling this segment. deflags (int | str | Sequence[int | str], optional) \u2014 Remove the flags from re.compile() while compilingthis segment. Methods __str__ ( ) (str) \u2014 String representation of this segment, depending on capture </> pretty ( indent , level ) (str) \u2014 Pretty print this segment, depending on capture </> method","title":"regexr.string.Captured"},{"location":"api/regexr.string/#regexrstringsegmentpretty_24","text":"</> Pretty print this segment, depending on capture Parameters indent (str) \u2014 The indent string. level (int) \u2014 The indent level. method","title":"regexr.string.Segment.pretty"},{"location":"api/regexr.string/#regexrstringsegmentstr_24","text":"</> String representation of this segment, depending on capture Returns (str) The final string representation of this segment. class","title":"regexr.string.Segment.str"},{"location":"api/regexr.string/#regexrstringregexr","text":"</> Bases str The entrance of the package to compose a regular expression It is actually a subclass of str , but with an extra method compile , which compiles the regular expression and returns a re.Pattern object. Parameters *segments (Segment or str) \u2014 The segments of the regular expression.When composing the regular expression, the segments are concatenated Methods __repr__ ( ) (str) \u2014 String representation of this regular expression </> compile ( flags ) (Pattern) \u2014 Compile the regular expression and return a re.Pattern object </> pretty ( indent ) (str) \u2014 Pretty print the regular expression </> method","title":"regexr.string.Regexr"},{"location":"api/regexr.string/#regexrstringregexrcompile","text":"</> Compile the regular expression and return a re.Pattern object See also re.compile() Parameters flags (int, optional) \u2014 The flags to be used when compiling the regular expression. method","title":"regexr.string.Regexr.compile"},{"location":"api/regexr.string/#regexrstringregexrpretty","text":"</> Pretty print the regular expression method","title":"regexr.string.Regexr.pretty"},{"location":"api/regexr.string/#regexrstringregexrrepr","text":"</> String representation of this regular expression","title":"regexr.string.Regexr.repr"},{"location":"api/source/regexr/","text":"SOURCE CODE regexr DOCS from .string import ( Segment , CharClass , OneOfChars , NoneOfChars , Look , LookAhead , LookBehind , LookAheadNot , LookBehindNot , Quantifier , ZeroOrMore , OneOrMore , Maybe , Repeat , RepeatExact , Lazy , Flag , InlineFlag , Raw , Or , Capture , NonCapture , Concat , Conditional , Captured , START , START_OF_STRING , END , END_OF_STRING , NUMBER , DIGIT , NUMBERS , DIGITS , MAYBE_NUMBERS , MAYBE_DIGITS , NON_NUMBER , NON_DIGIT , WORD , WORDS , MAYBE_WORDS , NON_WORD , WORD_BOUNDARY , NON_WORD_BOUNDARY , WHITESPACE , WHITESPACES , MAYBE_WHITESPACES , NON_WHITESPACE , SPACE , SPACES , MAYBE_SPACES , TAB , DOT , ANYCHAR , ANYCHARS , MAYBE_ANYCHARS , LETTER , LETTERS , MAYBE_LETTERS , LOWERCASE , LOWERCASES , MAYBE_LOWERCASES , UPPERCASE , UPPERCASES , MAYBE_UPPERCASES , ALNUM , ALNUMS , MAYBE_ALNUMS , Regexr , ) __version__ = \"0.0.2\"","title":"regexr"},{"location":"api/source/regexr.string/","text":"SOURCE CODE regexr. string DOCS r \"\"\"Regular expressions for humans Predefined patterns: START = Raw(\"^\", entire=True) START_OF_STRING = Raw(r\"\\A\", entire=True) END = Raw(\"$\", entire=True) END_OF_STRING = Raw(r\"\\Z\", entire=True) NUMBER = DIGIT = Raw(r\"\\d\", entire=True) NUMBERS = DIGITS = Raw(r\"\\d+\", entire=True) MAYBE_NUMBERS = MAYBE_DIGITS = Raw(r\"\\d*\", entire=True) NON_NUMBER = NON_DIGIT = Raw(r\"\\D\", entire=True) WORD = Raw(r\"\\w\", entire=True) WORDS = Raw(r\"\\w+\", entire=True) MAYBE_WORDS = Raw(r\"\\w*\", entire=True) NON_WORD = Raw(r\"\\W\", entire=True) WORD_BOUNDARY = Raw(r\"\\b\", entire=True) NON_WORD_BOUNDARY = Raw(r\"\\B\", entire=True) WHITESPACE = Raw(r\"\\s\", entire=True) WHITESPACES = Raw(r\"\\s+\", entire=True) MAYBE_WHITESPACES = Raw(r\"\\s*\", entire=True) NON_WHITESPACE = Raw(r\"\\S\", entire=True) SPACE = Raw(\" \", entire=True) SPACES = Raw(\" +\", entire=True) MAYBE_SPACES = Raw(\" *\", entire=True) TAB = Raw(r\"\\t\", entire=True) DOT = Raw(r\"\\.\", entire=True) ANYCHAR = Raw(\".\", entire=True) ANYCHARS = Raw(\".+\", entire=True) MAYBE_ANYCHARS = Raw(\".*\", entire=True) LETTER = Raw(\"[a-zA-Z]\", entire=True) LETTERS = Raw(\"[a-zA-Z]+\", entire=True) MAYBE_LETTERS = Raw(\"[a-zA-Z]*\", entire=True) LOWERCASE = Raw(\"[a-z]\", entire=True) LOWERCASES = Raw(\"[a-z]+\", entire=True) MAYBE_LOWERCASES = Raw(\"[a-z]*\", entire=True) UPPERCASE = Raw(\"[A-Z]\", entire=True) UPPERCASES = Raw(\"[A-Z]+\", entire=True) MAYBE_UPPERCASES = Raw(\"[A-Z]*\", entire=True) ALNUM = Raw(\"[a-zA-Z0-9]\", entire=True) ALNUMS = Raw(\"[a-zA-Z0-9]+\", entire=True) MAYBE_ALNUMS = Raw(\"[a-zA-Z0-9]*\", entire=True) \"\"\" from __future__ import annotations import re from abc import ABC , abstractproperty from typing import Sequence , Union SegmentType = Union [ \"Segment\" , str ] def _flags_to_str ( flags : int | str | Sequence [ int | str ]) -> str : \"\"\"Convert a set of flags to a string >>> _flags_to_str(re.IGNORECASE) # 'i' >>> _flags_to_str(re.IGNORECASE | re.MULTILINE) # 'im' \"\"\" if flags is None : return \"\" if isinstance ( flags , Sequence ) and not isinstance ( flags , str ): return \"\" . join ( _flags_to_str ( flag ) for flag in flags ) if isinstance ( flags , int ): out = [] if flags & re . A : out . append ( \"a\" ) if flags & re . I : out . append ( \"i\" ) if flags & re . L : out . append ( \"L\" ) if flags & re . M : out . append ( \"m\" ) if flags & re . S : out . append ( \"s\" ) if flags & re . U : out . append ( \"u\" ) if flags & re . X : out . append ( \"x\" ) return \"\" . join ( out ) # str if any ( c not in \"aiLmsux\" for c in flags ): raise ValueError ( f \"Invalid flag: { flags } , must be a subset of 'aiLmsux'\" ) return flags class Segment ( ABC ): DOCS \"\"\"Segments of a regular expression ClassVars: NONCAPTURING_WRAPPING: Whether we should wrap the segment with brackets when `capture` is `False`. In some cases, for example, `(abc)+` is already an entire group, it won't confuse the parser when it comes with other segments, such as `(abc)+d`. We don't need an extra brackets to separate it from other segments. However, we need brackets for other segments, such as `a|b|c`, because `a|b|cd` will confuse the parser. In such a case, we need `(?:a|b|c)d` if we don't need to capture the segment. Args: args: Another segments to be wrapped by this one. capture: The name of the capture, False to disable capturing and True to capture without name. flags: The flags to be used when compiling this segment. deflags: Remove the flags from `re.compile()` while compiling this segment. \"\"\" __slots__ = ( \"args\" , \"capture\" , \"flags\" ) NONCAPTURING_WRAPPING = True def __init__ ( self , * args : SegmentType , capture : bool | str = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : \"\"\"Constructor\"\"\" if isinstance ( capture , str ) and not capture . isidentifier (): raise ValueError ( f \"Invalid capture name: { capture } \" ) flags = _flags_to_str ( flags ) deflags = _flags_to_str ( deflags ) for flag in flags : if flag in deflags : raise ValueError ( f \"Flag ` { flag } ` turned on and off\" ) if deflags : deflags = f \"- { deflags } \" self . args = args self . capture = capture self . flags = f \" { flags }{ deflags } \" def _str_raw ( self ) -> str : \"\"\"Stringify this segment, without capturing/non-capturing brackets Returns: str: The stringified segment. \"\"\" return \"\" . join ( str ( part ) if isinstance ( part , Segment ) else re . escape ( part ) for part in self . args ) def _pretty_raw ( self , indent : str ) -> str : \"\"\"Pretty string representation of this segment, without capturing/non-capturing brackets \"\"\" out = [] for arg in self . args : if isinstance ( arg , Segment ): out . append ( arg . pretty ( indent , 0 )) else : # str out . append ( re . escape ( arg )) return \" \\n \" . join ( out ) def pretty ( self , indent : str , level : int ) -> str : DOCS \"\"\"Pretty print this segment, depending on `capture` Args: indent: The indent string. level: The indent level. \"\"\" arg = self . _pretty_raw ( indent ) if ( not self . capture and not self . NONCAPTURING_WRAPPING and not self . flags ): return \" \\n \" . join ( f \" { indent * level }{ line } \" for line in arg . splitlines () ) capture_start = ( \"(\" if self . capture is True else f \"(?P< { self . capture } >\" if self . capture else \"\" ) capture_end = \")\" if self . capture else \"\" flags_start = f \"(? { self . flags } :\" if self . flags else \"\" flags_end = \")\" if self . flags else \"\" if self . capture : start = f \" { indent * level }{ capture_start }{ flags_start } \" end = f \" { indent * level }{ flags_end }{ capture_end } \" elif self . __class__ . NONCAPTURING_WRAPPING and not self . flags : start = f \" { indent * level } (?:\" end = f \" { indent * level } )\" else : # self.flags not \"\" start = f \" { indent * level }{ flags_start } \" end = f \" { indent * level }{ flags_end } \" if \" \\n \" not in arg : return \"\" . join (( start , arg , end )) return \" \\n \" . join ( ( f \" { start } \" , * ( f \" { indent * ( level + 1 ) }{ line } \" for line in arg . splitlines () ), f \" { end } \" , ) ) def __str__ ( self ) -> str : DOCS \"\"\"String representation of this segment, depending on `capture` Returns: The final string representation of this segment. \"\"\" arg = self . _str_raw () flags_start = f \"(? { self . flags } :\" if self . flags else \"\" flags_end = \")\" if self . flags else \"\" arg = f \" { flags_start }{ arg }{ flags_end } \" if self . capture is True : return f \"( { arg } )\" if self . capture : return f \"(?P< { self . capture } > { arg } )\" if self . __class__ . NONCAPTURING_WRAPPING and not self . flags : return f \"(?: { arg } )\" return arg # Character classes class CharClass ( Segment , ABC ): DOCS \"\"\"Used to indicat a set of characters wrapped by `[]`\"\"\" NONCAPTURING_WRAPPING = False def _pretty_raw ( self , indent : str ) -> str : return self . _str_raw () def _str_raw ( self ) -> str : \"\"\"Stringify this segment, without capturing/non-capturing brackets Returns: str: The stringified segment. \"\"\" return \"\" . join ( str ( part ) if isinstance ( part , Segment ) else str ( part ) for part in self . args ) class OneOfChars ( CharClass ): DOCS \"\"\"Positive character set `[...]`\"\"\" def _str_raw ( self ) -> str : return f \"[ { super () . _str_raw () } ]\" class NoneOfChars ( CharClass ): DOCS \"\"\"Negative character set `[^...]`\"\"\" def _str_raw ( self ) -> str : return f \"[^ { super () . _str_raw () } ]\" # Look ahead/behind class Look ( Segment , ABC ): DOCS \"\"\"Look ahead or behind\"\"\" NONCAPTURING_WRAPPING = False PREFIX = \"?=\" def _str_raw ( self ) -> str : return f \"( { self . __class__ . PREFIX }{ super () . _str_raw () } )\" def _pretty_raw ( self , indent : str ) -> str : prettied = super () . _pretty_raw ( indent ) if \" \\n \" not in prettied : return f \"( { self . __class__ . PREFIX }{ prettied } )\" return \" \\n \" . join ([ f \"( { self . __class__ . PREFIX } \" , * ( f \" { indent }{ line } \" for line in prettied . splitlines ()), \")\" , ]) class LookAhead ( Look ): DOCS \"\"\"Look ahead `(?=...)`\"\"\" class LookBehind ( Look ): DOCS \"\"\"Look behind `(?<=...)`\"\"\" PREFIX = \"?<=\" class LookAheadNot ( Look ): DOCS \"\"\"Look ahead not `(?!...)`\"\"\" PREFIX = \"?!\" class LookBehindNot ( Look ): DOCS \"\"\"Look behind not `(?<!...)`\"\"\" PREFIX = \"?<!\" # Quantifiers class Quantifier ( Segment , ABC ): DOCS \"\"\"Quantifier `+`, `*`, `?`, `{m}` or `{m,n}`\"\"\" __slots__ = ( \"lazy\" ,) NONCAPTURING_WRAPPING = False def __init__ ( self , * args : SegmentType , lazy : bool = False , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags ) self . lazy = lazy @abstractproperty def _quantifier ( self ) -> str : \"\"\"The quantifier to quantify the pattern\"\"\" def _str_raw ( self ) -> str : qmark = \"?\" if self . lazy else \"\" if ( len ( self . args ) > 1 or ( isinstance ( self . args [ 0 ], str ) and len ( self . args [ 0 ]) > 1 ) or ( isinstance ( self . args [ 0 ], Raw ) and not self . args [ 0 ] . entire and not self . args [ 0 ] . capture ) or ( isinstance ( self . args [ 0 ], Segment ) and not isinstance ( self . args [ 0 ], ( Raw , Capture , Captured , CharClass ) ) and not self . args [ 0 ] . NONCAPTURING_WRAPPING and not self . args [ 0 ] . capture ) ): return f \"(?: { super () . _str_raw () } ) { self . _quantifier }{ qmark } \" return f \" { super () . _str_raw () }{ self . _quantifier }{ qmark } \" def _pretty_raw ( self , indent : str ) -> str : return self . _str_raw () class ZeroOrMore ( Quantifier ): DOCS \"\"\"`*` zero or more times\"\"\" _quantifier = \"*\" class OneOrMore ( Quantifier ): DOCS \"\"\"`+` one or more times\"\"\" _quantifier = \"+\" class Maybe ( Quantifier ): DOCS \"\"\"`?` zero or one times\"\"\" _quantifier = \"?\" class Repeat ( Quantifier ): DOCS \"\"\"Match from `m` to `n` repetitions `{m,n}` or `{m,}`\"\"\" __slots__ = ( \"m\" , \"n\" ) def __init__ ( self , * args : SegmentType , m : int , n : int = None , lazy : bool = False , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags , lazy = lazy , ) if m < 0 : raise ValueError ( \"`m` must be positive for `Repeat`\" ) if n is not None and n < m : raise ValueError ( \"`n` must be greater than or equal to `m` for `Repeat`\" ) self . m = m self . n = n @property def _quantifier ( self ) -> str : n = \"\" if self . n is None else self . n return f \" {{ { self . m } , { n } }} \" class RepeatExact ( Quantifier ): DOCS \"\"\"Match exact `m` repetitions `{m}`\"\"\" __slots__ = ( \"m\" ,) def __init__ ( self , * args : SegmentType , m : int , lazy : bool = False , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags , lazy = lazy , ) if m <= 0 : raise ValueError ( \"`m` must be greater than 0 for `Repeat`\" ) self . m = m @property def _quantifier ( self ) -> str : return f \" {{ { self . m } }} \" class Lazy ( Segment ): DOCS \"\"\"Non-greedy modifier `+?`, `*?`, `??`, `{m,}?` or `{m,n}?`\"\"\" NONCAPTURING_WRAPPING = False def __init__ ( self , * args : SegmentType , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : if len ( args ) != 1 : raise ValueError ( \"`Lazy` must have exactly one positional argument\" ) if ( not isinstance ( args [ 0 ], Quantifier ) and not ( isinstance ( args [ 0 ], Raw ) ) and not ( isinstance ( args [ 0 ], str ) and ( args [ 0 ][ - 1 ] in ( \"+\" , \"*\" , \"?\" ) or re . match ( r \"\\{\\d+(?:,\\d+)?\\}\" , args [ 0 ]) ) ) ): raise ValueError ( \"`Lazy` must be applied to a quantifier\" ) super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags ) def _str_raw ( self ) -> str : return f \" { super () . _str_raw () } ?\" def _pretty_raw ( self , indent : str ) -> str : return f \" { super () . _pretty_raw ( indent ) } ?\" class Flag ( Segment ): DOCS \"\"\"Flag `(?aiLmsux)`\"\"\" NONCAPTURING_WRAPPING = False def __init__ ( self , * args : str | int ) -> None : transformed_args = _flags_to_str ( args ) super () . __init__ ( transformed_args , capture = False ) def _str_raw ( self ) -> str : return f \"(? { super () . _str_raw () } )\" def _pretty_raw ( self , indent : str ) -> str : return self . _str_raw () class InlineFlag ( Segment ): DOCS \"\"\"Inline flag `(?aiLmsux-imsx:...)`\"\"\" NONCAPTURING_WRAPPING = False def __init__ ( self , * args : SegmentType , capture : bool | str = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : if flags is None and deflags is None : raise ValueError ( \"`InlineFlag` must have `flags` or `deflags`\" ) super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags , ) class Raw ( Segment ): DOCS \"\"\"Raw strings without escaping\"\"\" __slots__ = ( \"entire\" ,) NONCAPTURING_WRAPPING = False def __init__ ( self , * args : SegmentType , capture : bool = False , entire : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : if not all ( isinstance ( arg , str ) for arg in args ): raise ValueError ( \"`Raw` must be applied to strings.\" ) super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags ) self . entire = entire def _str_raw ( self ) -> str : return \"\" . join ( str ( part ) for part in self . args ) def _pretty_raw ( self , indent : str ) -> str : return self . _str_raw () # Other segments class Or ( Segment ): DOCS \"\"\"`|` connected segments\"\"\" def _str_raw ( self ) -> str : return \"|\" . join ( str ( part ) for part in self . args ) def _pretty_raw ( self , indent : str ) -> str : \"\"\"Pretty string representation of this segment, without capturing/non-capturing brackets \"\"\" out = [] has_newline = False for arg in self . args : if isinstance ( arg , Segment ): pretty_str = arg . pretty ( indent , 0 ) else : pretty_str = str ( arg ) if \" \\n \" in pretty_str : has_newline = True out . append ( pretty_str ) if not has_newline : return \"|\" . join ( out ) return \" \\n |\" . join ( out ) # Capture/non-capture class Capture ( Segment ): DOCS \"\"\"Capture a match `(...)`\"\"\" NONCAPTURING_WRAPPING = False def __init__ ( self , * args : SegmentType , name : bool | str = None , capture : bool | str = None , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : \"\"\"Constructor\"\"\" if name is None and capture is None : capture = True elif capture is None : capture = name assert capture is not False super () . __init__ ( * args , capture = capture , flags = flags , deflags = deflags ) class NonCapture ( Segment ): DOCS \"\"\"Non-capturing grouping `(?:...)`\"\"\" NONCAPTURING_WRAPPING = True def __init__ ( self , * args : SegmentType , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : \"\"\"Constructor\"\"\" super () . __init__ ( * args , capture = False , flags = flags , deflags = deflags ) class Concat ( Segment ): DOCS \"\"\"Concatenate segments\"\"\" NONCAPTURING_WRAPPING = False class Conditional ( Segment ): DOCS \"\"\"`(?(...)yes|no)` conditional pattern\"\"\" __slots__ = ( \"id_or_name\" , \"yes\" , \"no\" ) NONCAPTURING_WRAPPING = False def __init__ ( self , id_or_name : Captured | str | int , yes : SegmentType , no : SegmentType = None , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : \"\"\"Constructor\"\"\" if isinstance ( capture , str ) and not capture . isidentifier (): raise ValueError ( f \"Invalid capture name: { capture } \" ) if isinstance ( id_or_name , str ) and not id_or_name . isidentifier (): raise ValueError ( f \"Invalid id or name: { id_or_name } \" ) self . id_or_name = id_or_name self . yes = re . escape ( yes ) if isinstance ( yes , str ) else yes self . no = re . escape ( no ) if isinstance ( no , str ) else no super () . __init__ ( capture = capture , flags = flags , deflags = deflags ) def _str_raw ( self ) -> str : id_or_name = ( self . id_or_name . id_or_name if isinstance ( self . id_or_name , Captured ) else self . id_or_name ) no = f \"| { self . no } \" if self . no else \"\" return f \"(?( { id_or_name } ) { self . yes }{ no } )\" def _pretty_raw ( self , indent : str ) -> str : id_or_name = ( self . id_or_name . id_or_name if isinstance ( self . id_or_name , Captured ) else self . id_or_name ) yes = ( self . yes . pretty ( indent , 0 ) if isinstance ( self . yes , Segment ) else str ( self . yes ) ) no = ( \"\" if not self . no else f \"| { self . no . pretty ( indent , 0 ) } \" if isinstance ( self . no , Segment ) else f \"| { self . no } \" ) if \" \\n \" in yes or \" \\n \" in no : yes = \" \\n \" . join ( f \" { indent }{ line } \" for line in yes . split ( \" \\n \" )) no = \" \\n \" . join ( f \" { indent }{ line } \" for line in no . split ( \" \\n \" )) return f \"(?( { id_or_name } ) \\n { yes } \\n { no } \\n )\" return f \"(?( { id_or_name } ) { yes }{ no } )\" class Captured ( Segment ): DOCS \"\"\"`(?P=name)` captured group or \\\\1, \\\\2, ...\"\"\" __slots__ = ( \"id_or_name\" ,) NONCAPTURING_WRAPPING = False def __init__ ( self , id_or_name : str | int , capture : bool = False , flags : int | str | Sequence [ int | str ] = None , deflags : int | str | Sequence [ int | str ] = None , ) -> None : \"\"\"Constructor\"\"\" if isinstance ( capture , str ) and not capture . isidentifier (): raise ValueError ( f \"Invalid capture name: { capture } \" ) if isinstance ( id_or_name , str ) and not id_or_name . isidentifier (): raise ValueError ( f \"Invalid id or name: { id_or_name } \" ) self . id_or_name = id_or_name super () . __init__ ( capture = capture , flags = flags , deflags = deflags ) def _str_raw ( self ) -> str : if isinstance ( self . id_or_name , str ): return f \"(?P= { self . id_or_name } )\" return f \" \\\\ { self . id_or_name } \" def _pretty_raw ( self , indent : str ) -> str : return self . _str_raw () # Predefined patterns START = Raw ( \"^\" , entire = True ) START_OF_STRING = Raw ( r \"\\A\" , entire = True ) END = Raw ( \"$\" , entire = True ) END_OF_STRING = Raw ( r \"\\Z\" , entire = True ) NUMBER = DIGIT = Raw ( r \"\\d\" , entire = True ) NUMBERS = DIGITS = Raw ( r \"\\d+\" , entire = True ) MAYBE_NUMBERS = MAYBE_DIGITS = Raw ( r \"\\d*\" , entire = True ) NON_NUMBER = NON_DIGIT = Raw ( r \"\\D\" , entire = True ) WORD = Raw ( r \"\\w\" , entire = True ) WORDS = Raw ( r \"\\w+\" , entire = True ) MAYBE_WORDS = Raw ( r \"\\w*\" , entire = True ) NON_WORD = Raw ( r \"\\W\" , entire = True ) WORD_BOUNDARY = Raw ( r \"\\b\" , entire = True ) NON_WORD_BOUNDARY = Raw ( r \"\\B\" , entire = True ) WHITESPACE = Raw ( r \"\\s\" , entire = True ) WHITESPACES = Raw ( r \"\\s+\" , entire = True ) MAYBE_WHITESPACES = Raw ( r \"\\s*\" , entire = True ) NON_WHITESPACE = Raw ( r \"\\S\" , entire = True ) SPACE = Raw ( \" \" , entire = True ) SPACES = Raw ( \" +\" , entire = True ) MAYBE_SPACES = Raw ( \" *\" , entire = True ) TAB = Raw ( r \"\\t\" , entire = True ) DOT = Raw ( r \"\\.\" , entire = True ) ANYCHAR = Raw ( \".\" , entire = True ) ANYCHARS = Raw ( \".+\" , entire = True ) MAYBE_ANYCHARS = Raw ( \".*\" , entire = True ) LETTER = Raw ( \"[a-zA-Z]\" , entire = True ) LETTERS = Raw ( \"[a-zA-Z]+\" , entire = True ) MAYBE_LETTERS = Raw ( \"[a-zA-Z]*\" , entire = True ) LOWERCASE = Raw ( \"[a-z]\" , entire = True ) LOWERCASES = Raw ( \"[a-z]+\" , entire = True ) MAYBE_LOWERCASES = Raw ( \"[a-z]*\" , entire = True ) UPPERCASE = Raw ( \"[A-Z]\" , entire = True ) UPPERCASES = Raw ( \"[A-Z]+\" , entire = True ) MAYBE_UPPERCASES = Raw ( \"[A-Z]*\" , entire = True ) ALNUM = Raw ( \"[a-zA-Z0-9]\" , entire = True ) ALNUMS = Raw ( \"[a-zA-Z0-9]+\" , entire = True ) MAYBE_ALNUMS = Raw ( \"[a-zA-Z0-9]*\" , entire = True ) # Main class class Regexr ( str ): DOCS \"\"\"The entrance of the package to compose a regular expression It is actually a subclass of `str`, but with an extra method `compile`, which compiles the regular expression and returns a `re.Pattern` object. Args: *segments: The segments of the regular expression. When composing the regular expression, the segments are concatenated \"\"\" __slots__ = ( \"_segments\" ,) def __new__ ( cls , * segments : SegmentType ) -> Regexr : if ( any ( isinstance ( part , Flag ) for part in segments ) and not isinstance ( segments [ 0 ], Flag ) ): raise ValueError ( \"Flags must be the first segment.\" ) regexr = str . __new__ ( cls , \"\" . join ( re . escape ( part ) if isinstance ( part , str ) else str ( part ) for part in segments ) ) regexr . _segments = segments # type: ignore return regexr def compile ( self , flags : int = 0 ) -> re . Pattern : DOCS \"\"\"Compile the regular expression and return a `re.Pattern` object See also `re.compile()` Args: flags: The flags to be used when compiling the regular expression. \"\"\" return re . compile ( self , flags = flags ) def pretty ( self , indent : str = \" \" ) -> str : DOCS \"\"\"Pretty print the regular expression\"\"\" return \" \\n \" . join ( part . pretty ( indent , level = 0 ) if isinstance ( part , Segment ) else re . escape ( part ) for part in self . _segments # type: ignore ) def __repr__ ( self ) -> str : DOCS \"\"\"String representation of this regular expression\"\"\" return f \"<Regexr: r' { self } '>\"","title":"regexr.string"}]}